
<h2>üîê Password Security and Cracking Techniques</h2>

<p>Password security is a critical component of cybersecurity. Understanding how passwords can be compromised helps security professionals implement better defenses and educate users about password best practices. This module covers password security from both offensive and defensive perspectives.</p>

<div style="text-align: center; margin: 20px 0;">
    <img src="https://images.unsplash.com/photo-1614064641938-3bbee52942c7?w=800&h=400&fit=crop&auto=format" alt="Password security and cybersecurity concepts" style="max-width: 100%; height: auto; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">
</div>

<h3>üéØ Understanding Password Attacks</h3>

<p>Password attacks come in various forms, each with different methodologies and success rates:</p>

<h4>üìä Types of Password Attacks</h4>

<ul>
    <li><strong>Brute Force:</strong> Systematically trying every possible combination</li>
    <li><strong>Dictionary Attack:</strong> Using lists of common passwords and words</li>
    <li><strong>Hybrid Attack:</strong> Combining dictionary words with numbers and symbols</li>
    <li><strong>Rainbow Tables:</strong> Pre-computed hash lookups</li>
    <li><strong>Credential Stuffing:</strong> Using leaked password databases</li>
    <li><strong>Social Engineering:</strong> Manipulating humans to reveal passwords</li>
</ul>

<div style="text-align: center; margin: 20px 0;">
    <img src="https://images.unsplash.com/photo-1563013544-824ae1b704d3?w=700&h=350&fit=crop&auto=format" alt="Password attack methodologies visualization" style="max-width: 100%; height: auto; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">
</div>

<h3>üêç Python Password Cracking Tools</h3>

<h4>Basic Brute Force Implementation</h4>

<pre><code>import itertools
import hashlib
import time

def brute_force_password(target_hash, charset, max_length):
    """
    Basic brute force password cracker
    WARNING: For educational purposes only
    """
    for length in range(1, max_length + 1):
        for attempt in itertools.product(charset, repeat=length):
            password = ''.join(attempt)
            password_hash = hashlib.md5(password.encode()).hexdigest()
            
            if password_hash == target_hash:
                return password
            
        print(f"Completed length {length}")
    
    return None

# Example usage (for testing only)
charset = "abcdefghijklmnopqrstuvwxyz0123456789"
test_hash = hashlib.md5("test123".encode()).hexdigest()
result = brute_force_password(test_hash, charset, 7)
print(f"Password found: {result}")
</code></pre>

<h4>Dictionary Attack Implementation</h4>

<pre><code>import hashlib
import requests

def dictionary_attack(target_hash, wordlist_url=None, wordlist_file=None):
    """
    Dictionary-based password attack
    """
    wordlist = []
    
    if wordlist_file:
        with open(wordlist_file, 'r', encoding='utf-8', errors='ignore') as f:
            wordlist = [line.strip() for line in f]
    elif wordlist_url:
        response = requests.get(wordlist_url)
        wordlist = response.text.splitlines()
    
    for word in wordlist:
        # Try original word
        if hashlib.md5(word.encode()).hexdigest() == target_hash:
            return word
        
        # Try common variations
        variations = [
            word.lower(),
            word.upper(),
            word.capitalize(),
            word + "123",
            word + "!",
            "123" + word
        ]
        
        for variation in variations:
            if hashlib.md5(variation.encode()).hexdigest() == target_hash:
                return variation
    
    return None
</code></pre>

<div style="text-align: center; margin: 20px 0;">
    <img src="https://images.unsplash.com/photo-1526374965328-7f61d4dc18c5?w=700&h=350&fit=crop&auto=format" alt="Python code for security testing" style="max-width: 100%; height: auto; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">
</div>

<h3>üîí Hash Functions and Cryptography</h3>

<h4>Understanding Password Hashing</h4>

<p>Modern systems don't store passwords in plaintext. Instead, they use cryptographic hash functions:</p>

<ul>
    <li><strong>MD5:</strong> Fast but cryptographically broken</li>
    <li><strong>SHA-1:</strong> Deprecated due to vulnerabilities</li>
    <li><strong>SHA-256:</strong> Secure but fast (not ideal for passwords)</li>
    <li><strong>bcrypt:</strong> Designed specifically for password hashing</li>
    <li><strong>scrypt:</strong> Memory-hard function</li>
    <li><strong>Argon2:</strong> Modern, award-winning algorithm</li>
</ul>

<h4>Working with Different Hash Types</h4>

<pre><code>import hashlib
import bcrypt
from passlib.hash import argon2

class PasswordHasher:
    """
    Utility class for working with different hash types
    """
    
    @staticmethod
    def identify_hash_type(hash_string):
        """Identify the type of hash based on length and format"""
        if len(hash_string) == 32:
            return "MD5"
        elif len(hash_string) == 40:
            return "SHA-1"
        elif len(hash_string) == 64:
            return "SHA-256"
        elif hash_string.startswith("$2b$"):
            return "bcrypt"
        elif hash_string.startswith("$argon2"):
            return "Argon2"
        else:
            return "Unknown"
    
    @staticmethod
    def crack_md5_hash(target_hash, wordlist):
        """Attempt to crack MD5 hash using wordlist"""
        for word in wordlist:
            if hashlib.md5(word.encode()).hexdigest() == target_hash:
                return word
        return None
    
    @staticmethod
    def verify_bcrypt(password, hash_string):
        """Verify bcrypt hash"""
        return bcrypt.checkpw(password.encode(), hash_string.encode())
</code></pre>

<div style="text-align: center; margin: 20px 0;">
    <img src="https://images.unsplash.com/photo-1555949963-aa79dcee981c?w=600&h=300&fit=crop&auto=format" alt="Cryptographic hash functions and security" style="max-width: 100%; height: auto; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">
</div>

<h3>üõ°Ô∏è Advanced Password Cracking Techniques</h3>

<h4>Rule-Based Attacks</h4>

<p>Rule-based attacks apply transformations to dictionary words to generate password candidates:</p>

<pre><code>def apply_password_rules(base_word):
    """
    Apply common password transformation rules
    """
    rules = []
    
    # Capitalization rules
    rules.append(base_word.lower())
    rules.append(base_word.upper())
    rules.append(base_word.capitalize())
    rules.append(base_word.title())
    
    # Leetspeak substitutions
    leet_map = {
        'a': '@', 'e': '3', 'i': '1', 'o': '0', 
        's': '$', 't': '7', 'l': '1'
    }
    
    leet_word = base_word.lower()
    for char, replacement in leet_map.items():
        leet_word = leet_word.replace(char, replacement)
    rules.append(leet_word)
    
    # Number and symbol appendages
    for suffix in ['123', '!', '1', '2023', '2024']:
        rules.append(base_word + suffix)
        rules.append(suffix + base_word)
    
    # Reverse
    rules.append(base_word[::-1])
    
    return list(set(rules))  # Remove duplicates
</code></pre>

<h4>Mask Attacks</h4>

<pre><code>import itertools

def mask_attack(target_hash, mask_pattern):
    """
    Perform mask attack based on known password pattern
    
    Mask patterns:
    ?l = lowercase letters
    ?u = uppercase letters  
    ?d = digits
    ?s = special characters
    """
    
    charsets = {
        '?l': 'abcdefghijklmnopqrstuvwxyz',
        '?u': 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
        '?d': '0123456789',
        '?s': '!@#$%^&*()_+-=[]{}|;:,.<>?'
    }
    
    # Parse mask pattern
    positions = []
    i = 0
    while i < len(mask_pattern):
        if mask_pattern[i:i+2] in charsets:
            positions.append(charsets[mask_pattern[i:i+2]])
            i += 2
        else:
            positions.append(mask_pattern[i])
            i += 1
    
    # Generate candidates
    for combination in itertools.product(*positions):
        candidate = ''.join(combination)
        candidate_hash = hashlib.md5(candidate.encode()).hexdigest()
        
        if candidate_hash == target_hash:
            return candidate
    
    return None

# Example: Password pattern "Word123!"
# Mask: Company?d?d?d?s
</code></pre>

<div style="text-align: center; margin: 20px 0;">
    <img src="https://images.unsplash.com/photo-1550751827-4bd374c3f58b?w=800&h=400&fit=crop&auto=format" alt="Advanced password security techniques" style="max-width: 100%; height: auto; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">
</div>

<h3>üîç Password Analysis and Intelligence</h3>

<h4>Password Strength Assessment</h4>

<pre><code>import re
import math

class PasswordAnalyzer:
    """
    Analyze password strength and provide recommendations
    """
    
    @staticmethod
    def calculate_entropy(password):
        """Calculate password entropy in bits"""
        charset_size = 0
        
        if re.search(r'[a-z]', password):
            charset_size += 26
        if re.search(r'[A-Z]', password):
            charset_size += 26
        if re.search(r'[0-9]', password):
            charset_size += 10
        if re.search(r'[!@#$%^&*()_+\-=\[\]{}|;:,.<>?]', password):
            charset_size += 32
        
        if charset_size == 0:
            return 0
        
        return len(password) * math.log2(charset_size)
    
    @staticmethod
    def check_common_patterns(password):
        """Check for common weak password patterns"""
        patterns = {
            'Sequential numbers': r'(012|123|234|345|456|567|678|789)',
            'Sequential letters': r'(abc|bcd|cde|def|efg|fgh)',
            'Keyboard patterns': r'(qwe|asd|zxc|qaz|wsx)',
            'Years': r'(19|20)\d{2}',
            'Months': r'(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)',
            'Common words': r'(password|admin|user|login|welcome)'
        }
        
        found_patterns = []
        for pattern_name, pattern in patterns.items():
            if re.search(pattern, password.lower()):
                found_patterns.append(pattern_name)
        
        return found_patterns
    
    @staticmethod
    def assess_strength(password):
        """Comprehensive password strength assessment"""
        score = 0
        feedback = []
        
        # Length scoring
        if len(password) >= 12:
            score += 25
        elif len(password) >= 8:
            score += 15
        else:
            feedback.append("Use at least 8 characters (12+ recommended)")
        
        # Character variety
        if re.search(r'[a-z]', password):
            score += 10
        else:
            feedback.append("Include lowercase letters")
            
        if re.search(r'[A-Z]', password):
            score += 10
        else:
            feedback.append("Include uppercase letters")
            
        if re.search(r'[0-9]', password):
            score += 10
        else:
            feedback.append("Include numbers")
            
        if re.search(r'[!@#$%^&*()_+\-=\[\]{}|;:,.<>?]', password):
            score += 15
        else:
            feedback.append("Include special characters")
        
        # Pattern penalties
        patterns = PasswordAnalyzer.check_common_patterns(password)
        score -= len(patterns) * 10
        
        if patterns:
            feedback.append(f"Avoid common patterns: {', '.join(patterns)}")
        
        # Entropy bonus
        entropy = PasswordAnalyzer.calculate_entropy(password)
        if entropy > 60:
            score += 20
        elif entropy > 40:
            score += 10
        
        return min(100, max(0, score)), feedback, entropy
</code></pre>

<h3>üöÄ Automated Password Security Tools</h3>

<h4>Building a Comprehensive Password Auditor</h4>

<pre><code>import concurrent.futures
import time
from collections import defaultdict

class PasswordAuditor:
    """
    Comprehensive password security auditing tool
    """
    
    def __init__(self):
        self.wordlists = []
        self.rules = []
        self.stats = defaultdict(int)
    
    def load_wordlist(self, filename):
        """Load password wordlist from file"""
        try:
            with open(filename, 'r', encoding='utf-8', errors='ignore') as f:
                words = [line.strip() for line in f if line.strip()]
                self.wordlists.extend(words)
                print(f"Loaded {len(words)} words from {filename}")
        except FileNotFoundError:
            print(f"Wordlist file {filename} not found")
    
    def crack_hash_parallel(self, target_hash, num_threads=4):
        """
        Parallel password cracking using multiple threads
        """
        start_time = time.time()
        
        # Split wordlist for parallel processing
        chunk_size = len(self.wordlists) // num_threads
        chunks = [
            self.wordlists[i:i+chunk_size] 
            for i in range(0, len(self.wordlists), chunk_size)
        ]
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=num_threads) as executor:
            futures = []
            
            for chunk in chunks:
                future = executor.submit(self._crack_chunk, target_hash, chunk)
                futures.append(future)
            
            for future in concurrent.futures.as_completed(futures):
                result = future.result()
                if result:
                    elapsed = time.time() - start_time
                    print(f"Password cracked in {elapsed:.2f} seconds: {result}")
                    return result
        
        elapsed = time.time() - start_time
        print(f"Password not found after {elapsed:.2f} seconds")
        return None
    
    def _crack_chunk(self, target_hash, wordlist_chunk):
        """Process a chunk of the wordlist"""
        for word in wordlist_chunk:
            # Try original word and variations
            candidates = apply_password_rules(word)
            
            for candidate in candidates:
                self.stats['attempts'] += 1
                
                if hashlib.md5(candidate.encode()).hexdigest() == target_hash:
                    return candidate
                
                # Progress reporting
                if self.stats['attempts'] % 10000 == 0:
                    print(f"Tried {self.stats['attempts']} passwords...")
        
        return None
    
    def generate_report(self, password_hashes, output_file="audit_report.txt"):
        """Generate comprehensive audit report"""
        cracked = 0
        total = len(password_hashes)
        
        with open(output_file, 'w') as report:
            report.write("PASSWORD SECURITY AUDIT REPORT\n")
            report.write("=" * 40 + "\n\n")
            
            for i, (user, hash_value) in enumerate(password_hashes.items()):
                print(f"Auditing {user} ({i+1}/{total})...")
                
                result = self.crack_hash_parallel(hash_value)
                
                if result:
                    cracked += 1
                    strength_score, feedback, entropy = PasswordAnalyzer.assess_strength(result)
                    
                    report.write(f"User: {user}\n")
                    report.write(f"Password: {result}\n")
                    report.write(f"Strength Score: {strength_score}/100\n")
                    report.write(f"Entropy: {entropy:.2f} bits\n")
                    report.write(f"Issues: {', '.join(feedback)}\n")
                    report.write("-" * 30 + "\n")
                else:
                    report.write(f"User: {user}\n")
                    report.write("Password: NOT CRACKED\n")
                    report.write("-" * 30 + "\n")
            
            report.write(f"\nSUMMARY:\n")
            report.write(f"Total passwords: {total}\n")
            report.write(f"Cracked: {cracked} ({(cracked/total)*100:.1f}%)\n")
            report.write(f"Secure: {total-cracked} ({((total-cracked)/total)*100:.1f}%)\n")
        
        print(f"Audit report saved to {output_file}")
</code></pre>

<div style="text-align: center; margin: 20px 0;">
    <img src="https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=700&h=350&fit=crop&auto=format" alt="Automated security testing tools" style="max-width: 100%; height: auto; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">
</div>

<h3>üõ°Ô∏è Defense Strategies and Best Practices</h3>

<h4>Password Policy Implementation</h4>

<pre><code>class PasswordPolicy:
    """
    Implement and enforce password policies
    """
    
    def __init__(self, min_length=8, require_uppercase=True, 
                 require_lowercase=True, require_digits=True, 
                 require_special=True, max_age_days=90):
        self.min_length = min_length
        self.require_uppercase = require_uppercase
        self.require_lowercase = require_lowercase
        self.require_digits = require_digits
        self.require_special = require_special
        self.max_age_days = max_age_days
        
        # Common weak passwords to block
        self.blacklisted_passwords = [
            'password', '123456', 'password123', 'admin', 
            'qwerty', 'welcome', 'login', 'user'
        ]
    
    def validate_password(self, password, username=None):
        """Validate password against policy"""
        errors = []
        
        # Length check
        if len(password) < self.min_length:
            errors.append(f"Password must be at least {self.min_length} characters")
        
        # Character requirements
        if self.require_uppercase and not re.search(r'[A-Z]', password):
            errors.append("Password must contain uppercase letters")
        
        if self.require_lowercase and not re.search(r'[a-z]', password):
            errors.append("Password must contain lowercase letters")
        
        if self.require_digits and not re.search(r'[0-9]', password):
            errors.append("Password must contain numbers")
        
        if self.require_special and not re.search(r'[!@#$%^&*()_+\-=\[\]{}|;:,.<>?]', password):
            errors.append("Password must contain special characters")
        
        # Username similarity check
        if username and username.lower() in password.lower():
            errors.append("Password cannot contain username")
        
        # Blacklist check
        if password.lower() in self.blacklisted_passwords:
            errors.append("Password is too common and not allowed")
        
        # Pattern checks
        patterns = PasswordAnalyzer.check_common_patterns(password)
        if patterns:
            errors.append(f"Password contains weak patterns: {', '.join(patterns)}")
        
        return len(errors) == 0, errors
    
    def generate_secure_password(self, length=16):
        """Generate a secure password meeting policy requirements"""
        import secrets
        import string
        
        # Define character sets
        lowercase = string.ascii_lowercase
        uppercase = string.ascii_uppercase
        digits = string.digits
        special = "!@#$%^&*()_+-="
        
        # Ensure at least one character from each required set
        password = []
        
        if self.require_lowercase:
            password.append(secrets.choice(lowercase))
        if self.require_uppercase:
            password.append(secrets.choice(uppercase))
        if self.require_digits:
            password.append(secrets.choice(digits))
        if self.require_special:
            password.append(secrets.choice(special))
        
        # Fill remaining length with random characters
        all_chars = lowercase + uppercase + digits + special
        for _ in range(length - len(password)):
            password.append(secrets.choice(all_chars))
        
        # Shuffle the password
        secrets.SystemRandom().shuffle(password)
        
        return ''.join(password)
</code></pre>

<h3>üí° Multi-Factor Authentication Integration</h3>

<p>Modern password security relies on multi-factor authentication (MFA) to provide additional layers of protection:</p>

<ul>
    <li><strong>TOTP (Time-based OTP):</strong> Google Authenticator, Authy</li>
    <li><strong>SMS/Voice:</strong> Text message or voice call verification</li>
    <li><strong>Hardware Tokens:</strong> YubiKey, RSA SecurID</li>
    <li><strong>Biometric:</strong> Fingerprint, facial recognition</li>
    <li><strong>Push Notifications:</strong> Mobile app confirmations</li>
</ul>

<div style="text-align: center; margin: 20px 0;">
    <img src="https://images.unsplash.com/photo-1563013544-824ae1b704d3?w=600&h=300&fit=crop&auto=format" alt="Multi-factor authentication security" style="max-width: 100%; height: auto; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">
</div>

<h3>üìã Legal and Ethical Considerations</h3>

<div style="background-color: #fff3cd; padding: 15px; border-left: 4px solid #ffc107; margin: 20px 0;">
    <strong>Important Legal Notice:</strong> Password cracking tools should only be used on systems you own or have explicit written permission to test. Unauthorized password cracking is illegal in most jurisdictions.
</div>

<h4>Responsible Disclosure</h4>

<ul>
    <li><strong>Document Everything:</strong> Keep detailed records of vulnerabilities found</li>
    <li><strong>Follow Disclosure Policies:</strong> Respect organization's vulnerability disclosure processes</li>
    <li><strong>Provide Solutions:</strong> Offer recommendations for remediation</li>
    <li><strong>Maintain Confidentiality:</strong> Protect sensitive information discovered during testing</li>
</ul>

<h3>üéì Advanced Topics and Future Learning</h3>

<h4>Emerging Threats and Technologies</h4>

<ul>
    <li><strong>GPU-Accelerated Cracking:</strong> Using graphics cards for faster computation</li>
    <li><strong>Cloud-Based Attacks:</strong> Distributed password cracking</li>
    <li><strong>AI-Powered Attacks:</strong> Machine learning for password prediction</li>
    <li><strong>Quantum Computing:</strong> Future implications for cryptography</li>
    <li><strong>Passwordless Authentication:</strong> WebAuthn, FIDO2, biometrics</li>
</ul>

<div style="text-align: center; margin: 20px 0;">
    <img src="https://images.unsplash.com/photo-1518709268805-4e9042af2176?w=700&h=350&fit=crop&auto=format" alt="Future of password security and authentication" style="max-width: 100%; height: auto; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">
</div>

<h3>üîß Practical Exercises</h3>

<h4>Hands-On Lab Activities</h4>

<ol>
    <li><strong>Password Strength Analyzer:</strong> Build a tool to assess password security</li>
    <li><strong>Hash Identification:</strong> Create a script to identify hash types</li>
    <li><strong>Dictionary Generator:</strong> Build custom wordlists from public data</li>
    <li><strong>Policy Enforcer:</strong> Implement password policy validation</li>
    <li><strong>Audit Report Generator:</strong> Create comprehensive security reports</li>
</ol>

<div style="background-color: #d4edda; padding: 15px; border-left: 4px solid #28a745; margin: 20px 0;">
    <strong>Key Takeaways:</strong> Password security is a critical skill for ethical hackers. Understanding both attack and defense techniques helps create more secure systems. Always use these skills responsibly and within legal boundaries.
</div>

<h3>üìö Next Steps</h3>

<p>In the next module, you'll learn about wireless network security, including WiFi penetration testing, WPA/WPA2 analysis, and securing wireless infrastructures using Python tools.</p>
