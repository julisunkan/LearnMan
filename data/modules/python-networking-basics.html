
<h2>üåê Python Networking Fundamentals</h2>

<p>Network programming is the backbone of ethical hacking. Understanding how computers communicate over networks and how to manipulate these communications using Python is essential for any security professional. This module will teach you the fundamental concepts and practical skills needed to build network-based security tools.</p>

<div style="text-align: center; margin: 20px 0;">
    <img src="https://images.unsplash.com/photo-1558494949-ef010cbdcc31?w=800&h=400&fit=crop&auto=format" alt="Network cables and connections representing networking fundamentals" style="max-width: 100%; height: auto; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">
</div>

<h3>üîå Understanding Network Protocols</h3>

<p>Before diving into Python networking, it's crucial to understand the protocols that govern network communication:</p>

<h4>üìä The OSI Model</h4>
<p>The Open Systems Interconnection (OSI) model provides a conceptual framework for understanding network communications:</p>

<div style="text-align: center; margin: 20px 0;">
    <img src="https://images.unsplash.com/photo-1544197150-b99a580bb7a8?w=700&h=400&fit=crop&auto=format" alt="Network layers and OSI model visualization" style="max-width: 100%; height: auto; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">
</div>

<ol>
    <li><strong>Physical Layer:</strong> Hardware transmission (cables, switches)</li>
    <li><strong>Data Link Layer:</strong> Node-to-node delivery (Ethernet, WiFi)</li>
    <li><strong>Network Layer:</strong> Path determination (IP, ICMP)</li>
    <li><strong>Transport Layer:</strong> End-to-end delivery (TCP, UDP)</li>
    <li><strong>Session Layer:</strong> Dialog control</li>
    <li><strong>Presentation Layer:</strong> Data formatting and encryption</li>
    <li><strong>Application Layer:</strong> Network services (HTTP, FTP, SSH)</li>
</ol>

<h4>üöõ TCP vs UDP</h4>

<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0;">
    <div style="background-color: #e3f2fd; padding: 15px; border-radius: 8px;">
        <h5>üì¶ TCP (Transmission Control Protocol)</h5>
        <ul>
            <li>Connection-oriented</li>
            <li>Reliable delivery</li>
            <li>Error checking and correction</li>
            <li>Ordered data delivery</li>
            <li>Flow control</li>
            <li>Used for: HTTP, HTTPS, SSH, FTP</li>
        </ul>
    </div>
    <div style="background-color: #f3e5f5; padding: 15px; border-radius: 8px;">
        <h5>‚ö° UDP (User Datagram Protocol)</h5>
        <ul>
            <li>Connectionless</li>
            <li>Fast transmission</li>
            <li>No error correction</li>
            <li>No delivery guarantee</li>
            <li>Lightweight</li>
            <li>Used for: DNS, DHCP, Streaming</li>
        </ul>
    </div>
</div>

<h3>üêç Python Socket Programming</h3>

<p>Sockets are the foundation of network programming in Python. They provide a way for programs to communicate over a network.</p>

<div style="text-align: center; margin: 20px 0;">
    <img src="https://images.unsplash.com/photo-1516321318423-f06f85e504b3?w=600&h=300&fit=crop&auto=format" alt="Python code on screen showing socket programming" style="max-width: 100%; height: auto; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">
</div>

<h4>üîß Basic Socket Operations</h4>

<pre style="background-color: #f8f9fa; padding: 15px; border-radius: 8px; overflow-x: auto;">
<code>import socket

# Create a TCP socket
tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# Create a UDP socket
udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# Socket parameters:
# AF_INET: IPv4 address family
# AF_INET6: IPv6 address family
# SOCK_STREAM: TCP socket type
# SOCK_DGRAM: UDP socket type
</code></pre>

<h4>üñ•Ô∏è Creating a Simple TCP Client</h4>

<pre style="background-color: #f8f9fa; padding: 15px; border-radius: 8px; overflow-x: auto;">
<code>import socket

def tcp_client(host, port):
    try:
        # Create a TCP socket
        client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        
        # Connect to the server
        client_socket.connect((host, port))
        print(f"Connected to {host}:{port}")
        
        # Send data
        message = "Hello, Server!"
        client_socket.send(message.encode())
        
        # Receive response
        response = client_socket.recv(1024)
        print(f"Server response: {response.decode()}")
        
    except Exception as e:
        print(f"Error: {e}")
    finally:
        client_socket.close()

# Usage
tcp_client('127.0.0.1', 8080)
</code></pre>

<h4>üè† Creating a Simple TCP Server</h4>

<pre style="background-color: #f8f9fa; padding: 15px; border-radius: 8px; overflow-x: auto;">
<code>import socket
import threading

def handle_client(client_socket, address):
    try:
        print(f"Connection from {address}")
        
        # Receive data from client
        data = client_socket.recv(1024)
        print(f"Received: {data.decode()}")
        
        # Send response
        response = "Hello, Client!"
        client_socket.send(response.encode())
        
    except Exception as e:
        print(f"Error handling client {address}: {e}")
    finally:
        client_socket.close()

def tcp_server(host, port):
    try:
        # Create a TCP socket
        server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        
        # Bind to address and port
        server_socket.bind((host, port))
        
        # Listen for connections
        server_socket.listen(5)
        print(f"Server listening on {host}:{port}")
        
        while True:
            # Accept client connection
            client_socket, address = server_socket.accept()
            
            # Handle client in a separate thread
            client_thread = threading.Thread(
                target=handle_client, 
                args=(client_socket, address)
            )
            client_thread.start()
            
    except Exception as e:
        print(f"Server error: {e}")
    finally:
        server_socket.close()

# Usage
tcp_server('0.0.0.0', 8080)
</code></pre>

<h3>üåç Working with HTTP Requests</h3>

<p>The <code>requests</code> library makes HTTP programming much easier than using raw sockets. It's essential for web application testing.</p>

<div style="text-align: center; margin: 20px 0;">
    <img src="https://images.unsplash.com/photo-1461749280684-dccba630e2f6?w=700&h=350&fit=crop&auto=format" alt="Web development and HTTP requests visualization" style="max-width: 100%; height: auto; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">
</div>

<h4>üì° Basic HTTP Operations</h4>

<pre style="background-color: #f8f9fa; padding: 15px; border-radius: 8px; overflow-x: auto;">
<code>import requests
import json

# GET request
def perform_get_request(url):
    try:
        response = requests.get(url, timeout=10)
        print(f"Status Code: {response.status_code}")
        print(f"Headers: {response.headers}")
        print(f"Content: {response.text[:200]}...")
        return response
    except requests.exceptions.RequestException as e:
        print(f"Request failed: {e}")

# POST request with data
def perform_post_request(url, data):
    try:
        headers = {'Content-Type': 'application/json'}
        response = requests.post(
            url, 
            data=json.dumps(data), 
            headers=headers,
            timeout=10
        )
        print(f"POST Status: {response.status_code}")
        print(f"Response: {response.text}")
        return response
    except requests.exceptions.RequestException as e:
        print(f"POST request failed: {e}")

# Usage examples
perform_get_request('https://httpbin.org/get')
perform_post_request('https://httpbin.org/post', {'key': 'value'})
</code></pre>

<h4>üîç Advanced HTTP Features</h4>

<pre style="background-color: #f8f9fa; padding: 15px; border-radius: 8px; overflow-x: auto;">
<code>import requests
from requests.auth import HTTPBasicAuth

# Session for persistent connections
session = requests.Session()

# Custom headers
headers = {
    'User-Agent': 'Custom Security Scanner 1.0',
    'Accept': 'application/json',
    'Authorization': 'Bearer your-token-here'
}

# Basic authentication
response = requests.get(
    'https://httpbin.org/basic-auth/user/pass',
    auth=HTTPBasicAuth('user', 'pass')
)

# Handle cookies
session.cookies.set('session_id', 'abc123')

# Proxy support (useful for traffic analysis)
proxies = {
    'http': 'http://proxy.example.com:8080',
    'https': 'https://proxy.example.com:8080'
}

response = requests.get(
    'https://httpbin.org/ip',
    proxies=proxies
)

# SSL verification control
response = requests.get(
    'https://example.com',
    verify=False  # Disable SSL verification (use cautiously)
)
</code></pre>

<h3>üîé Network Information Gathering</h3>

<p>Python provides several modules for gathering network information, which is crucial for reconnaissance.</p>

<div style="text-align: center; margin: 20px 0;">
    <img src="https://images.unsplash.com/photo-1555949963-aa79dcee981c?w=600&h=300&fit=crop&auto=format" alt="Network analysis and information gathering tools" style="max-width: 100%; height: auto; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">
</div>

<h4>üåê DNS Resolution</h4>

<pre style="background-color: #f8f9fa; padding: 15px; border-radius: 8px; overflow-x: auto;">
<code>import socket
import dns.resolver

def get_ip_address(hostname):
    try:
        ip_address = socket.gethostbyname(hostname)
        print(f"{hostname} -> {ip_address}")
        return ip_address
    except socket.gaierror as e:
        print(f"DNS resolution failed: {e}")
        return None

def reverse_dns_lookup(ip_address):
    try:
        hostname = socket.gethostbyaddr(ip_address)
        print(f"{ip_address} -> {hostname[0]}")
        return hostname[0]
    except socket.herror as e:
        print(f"Reverse DNS lookup failed: {e}")
        return None

def advanced_dns_lookup(domain, record_type='A'):
    try:
        answers = dns.resolver.resolve(domain, record_type)
        for answer in answers:
            print(f"{domain} {record_type} record: {answer}")
    except Exception as e:
        print(f"DNS lookup failed: {e}")

# Usage examples
get_ip_address('google.com')
reverse_dns_lookup('8.8.8.8')
advanced_dns_lookup('google.com', 'MX')  # Mail exchange records
advanced_dns_lookup('google.com', 'TXT')  # Text records
</code></pre>

<h4>üìç Network Interface Information</h4>

<pre style="background-color: #f8f9fa; padding: 15px; border-radius: 8px; overflow-x: auto;">
<code>import netifaces
import psutil

def get_network_interfaces():
    interfaces = netifaces.interfaces()
    for interface in interfaces:
        print(f"\nInterface: {interface}")
        addresses = netifaces.ifaddresses(interface)
        
        # IPv4 addresses
        if netifaces.AF_INET in addresses:
            for addr in addresses[netifaces.AF_INET]:
                print(f"  IPv4: {addr['addr']}")
                print(f"  Netmask: {addr['netmask']}")
        
        # IPv6 addresses
        if netifaces.AF_INET6 in addresses:
            for addr in addresses[netifaces.AF_INET6]:
                print(f"  IPv6: {addr['addr']}")

def get_network_stats():
    stats = psutil.net_io_counters()
    print(f"Bytes sent: {stats.bytes_sent}")
    print(f"Bytes received: {stats.bytes_recv}")
    print(f"Packets sent: {stats.packets_sent}")
    print(f"Packets received: {stats.packets_recv}")

# Usage
get_network_interfaces()
get_network_stats()
</code></pre>

<h3>üì¶ Packet Manipulation with Scapy</h3>

<p>Scapy is a powerful Python library for packet manipulation, network scanning, and protocol analysis.</p>

<div style="text-align: center; margin: 20px 0;">
    <img src="https://images.unsplash.com/photo-1518709268805-4e9042af2176?w=700&h=350&fit=crop&auto=format" alt="Network packet analysis and manipulation" style="max-width: 100%; height: auto; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">
</div>

<h4>üîß Basic Scapy Operations</h4>

<pre style="background-color: #f8f9fa; padding: 15px; border-radius: 8px; overflow-x: auto;">
<code>from scapy.all import *
import time

# Create an IP packet
ip_packet = IP(dst="8.8.8.8")
print(ip_packet.summary())

# Create an ICMP packet (ping)
icmp_packet = ICMP()

# Combine packets
ping_packet = ip_packet / icmp_packet

# Send and receive packets
def send_ping(target):
    packet = IP(dst=target) / ICMP()
    response = sr1(packet, timeout=2, verbose=False)
    
    if response:
        print(f"Ping to {target}: Reply received")
        return True
    else:
        print(f"Ping to {target}: No reply")
        return False

# TCP SYN packet creation
def create_syn_packet(target, port):
    ip = IP(dst=target)
    tcp = TCP(dport=port, flags="S")
    packet = ip / tcp
    return packet

# Packet sniffing
def packet_sniffer(interface="eth0", count=10):
    print(f"Sniffing {count} packets on {interface}...")
    packets = sniff(iface=interface, count=count)
    
    for packet in packets:
        if packet.haslayer(IP):
            print(f"Source: {packet[IP].src} -> Destination: {packet[IP].dst}")

# Usage examples
send_ping("8.8.8.8")
syn_packet = create_syn_packet("google.com", 80)
print(syn_packet.summary())
</code></pre>

<h3>üõ°Ô∏è Error Handling and Security Considerations</h3>

<div style="background-color: #fff3cd; padding: 15px; border-left: 4px solid #ffc107; margin: 20px 0;">
    <strong>Security Note:</strong> Always implement proper error handling and security measures when developing network tools.
</div>

<h4>‚ö†Ô∏è Common Security Practices</h4>

<pre style="background-color: #f8f9fa; padding: 15px; border-radius: 8px; overflow-x: auto;">
<code>import socket
import ssl
import logging

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def secure_tcp_client(host, port, use_ssl=True):
    try:
        # Create socket
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        
        # Apply SSL if requested
        if use_ssl:
            context = ssl.create_default_context()
            sock = context.wrap_socket(sock, server_hostname=host)
        
        # Set timeout to prevent hanging
        sock.settimeout(10)
        
        # Connect with error handling
        sock.connect((host, port))
        logger.info(f"Connected to {host}:{port}")
        
        return sock
        
    except socket.timeout:
        logger.error("Connection timeout")
    except socket.gaierror:
        logger.error("DNS resolution failed")
    except ConnectionRefusedError:
        logger.error("Connection refused")
    except ssl.SSLError as e:
        logger.error(f"SSL error: {e}")
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
    
    return None

def validate_input(ip_address):
    """Validate IP address input to prevent injection attacks"""
    try:
        socket.inet_aton(ip_address)
        return True
    except socket.error:
        return False

# Rate limiting to avoid overwhelming targets
import time
from functools import wraps

def rate_limit(calls_per_second=1):
    def decorator(func):
        last_called = [0.0]
        
        @wraps(func)
        def wrapper(*args, **kwargs):
            elapsed = time.time() - last_called[0]
            wait_time = 1.0 / calls_per_second
            
            if elapsed < wait_time:
                time.sleep(wait_time - elapsed)
            
            last_called[0] = time.time()
            return func(*args, **kwargs)
        
        return wrapper
    return decorator

@rate_limit(calls_per_second=2)
def rate_limited_request(url):
    response = requests.get(url)
    return response
</code></pre>

<h3>üéØ Practical Exercises</h3>

<div style="text-align: center; margin: 20px 0;">
    <img src="https://images.unsplash.com/photo-1434030216411-0b793f4b4173?w=600&h=300&fit=crop&auto=format" alt="Programming practice and hands-on exercises" style="max-width: 100%; height: auto; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">
</div>

<h4>üèÉ‚Äç‚ôÇÔ∏è Exercise 1: Banner Grabbing Tool</h4>
<p>Create a tool that connects to various services and retrieves their banners:</p>

<pre style="background-color: #f8f9fa; padding: 15px; border-radius: 8px; overflow-x: auto;">
<code>import socket

def banner_grabber(host, port, timeout=5):
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        sock.connect((host, port))
        
        # Send a basic request
        sock.send(b"HEAD / HTTP/1.1\r\nHost: " + host.encode() + b"\r\n\r\n")
        
        # Receive banner
        banner = sock.recv(1024).decode().strip()
        print(f"Banner from {host}:{port}")
        print(banner)
        
    except Exception as e:
        print(f"Error grabbing banner from {host}:{port} - {e}")
    finally:
        sock.close()

# Test with common ports
common_ports = [21, 22, 23, 25, 53, 80, 110, 143, 443, 993, 995]
target = "example.com"

for port in common_ports:
    banner_grabber(target, port)
</code></pre>

<h4>üîç Exercise 2: HTTP Header Analyzer</h4>
<p>Build a tool to analyze HTTP headers for security information:</p>

<pre style="background-color: #f8f9fa; padding: 15px; border-radius: 8px; overflow-x: auto;">
<code>import requests

def analyze_http_headers(url):
    try:
        response = requests.get(url, timeout=10)
        headers = response.headers
        
        print(f"Analyzing headers for: {url}")
        print(f"Status Code: {response.status_code}")
        print("-" * 50)
        
        # Security headers to check
        security_headers = {
            'X-Frame-Options': 'Clickjacking protection',
            'X-XSS-Protection': 'XSS filtering',
            'X-Content-Type-Options': 'MIME type sniffing protection',
            'Strict-Transport-Security': 'HTTPS enforcement',
            'Content-Security-Policy': 'Content injection protection',
            'X-Permitted-Cross-Domain-Policies': 'Cross-domain policy'
        }
        
        print("Security Headers Analysis:")
        for header, description in security_headers.items():
            if header in headers:
                print(f"‚úì {header}: {headers[header]}")
            else:
                print(f"‚úó {header}: Missing ({description})")
        
        print("\nAll Headers:")
        for header, value in headers.items():
            print(f"{header}: {value}")
            
    except Exception as e:
        print(f"Error analyzing {url}: {e}")

# Usage
analyze_http_headers("https://google.com")
</code></pre>

<h3>üìö Key Takeaways</h3>

<ul>
    <li><strong>Socket Programming:</strong> Foundation for custom network tools</li>
    <li><strong>HTTP Libraries:</strong> Essential for web application testing</li>
    <li><strong>Packet Manipulation:</strong> Advanced network analysis with Scapy</li>
    <li><strong>Error Handling:</strong> Robust tools require proper exception handling</li>
    <li><strong>Security Practices:</strong> Rate limiting and input validation</li>
    <li><strong>Protocol Understanding:</strong> Know TCP, UDP, and HTTP fundamentals</li>
</ul>

<div style="background-color: #d4edda; padding: 15px; border-left: 4px solid #28a745; margin: 20px 0;">
    <strong>Next Module:</strong> Now that you understand Python networking fundamentals, you're ready to build advanced network scanning tools. The next module will teach you to create port scanners, host discovery tools, and network mappers.
</div>
